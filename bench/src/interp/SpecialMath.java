/****************************************************************************
Copyright (c) 2012, Colorado School of Mines and others. All rights reserved.
This program and accompanying materials are made available under the terms of
the Common Public License - v1.0, which accompanies this distribution, and is
available at http://www.eclipse.org/legal/cpl-v10.html
****************************************************************************/
package interp;

import static java.lang.Math.*;
import edu.mines.jtk.util.Check;

/*
 * This class was derived in part from software in the Boost C++ library, 
 * use of which is governed by the following license:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * Special mathematical functions.
 * Adapted from Boost C++ libraries.
 * @author Dave Hale, Colorado School of Mines.
 */
public class SpecialMath {

  /**
   * Evaluates the Bessel function of the first kind and order 0.
   * @param x function argument.
   * @return the function value.
   */
  public static double j0(double x) {
    return J0.j0(x);
  }

  /**
   * Evaluates the Bessel function of the first kind and order 0.
   * @param x function argument.
   * @return the function value.
   */
  public static float j0(float x) {
    return (float)J0.j0(x);
  }

  /**
   * Evaluates the Bessel function of the first kind and order 1.
   * @param x function argument.
   * @return the function value.
   */
  public static double j1(double x) {
    return J1.j1(x);
  }

  /**
   * Evaluates the Bessel function of the first kind and order 1.
   * @param x function argument.
   * @return the function value.
   */
  public static float j1(float x) {
    return (float)J1.j1(x);
  }

  /**
   * Evaluates the modified Bessel function of the first kind and order 0.
   * @param x function argument.
   * @return the function value.
   */
  public static double i0(double x) {
    return I0.i0(x);
  }

  /**
   * Evaluates the modified Bessel function of the first kind and order 0.
   * @param x function argument.
   * @return the function value.
   */
  public static float i0(float x) {
    return (float)I0.i0(x);
  }

  /**
   * Evaluates the modified Bessel function of the second kind and order 0.
   * @param x function argument.
   * @return the function value.
   */
  public static double k0(double x) {
    return K0.k0(x);
  }

  /**
   * Evaluates the modified Bessel function of the second kind and order 0.
   * @param x function argument.
   * @return the function value.
   */
  public static float k0(float x) {
    return (float)K0.k0(x);
  }

  /**
   * Evaluates the modified Bessel function of the second kind and order 1.
   * @param x function argument.
   * @return the function value.
   */
  public static double k1(double x) {
    return K1.k1(x);
  }

  /**
   * Evaluates the modified Bessel function of the second kind and order 1.
   * @param x function argument.
   * @return the function value.
   */
  public static float k1(float x) {
    return (float)K1.k1(x);
  }

  /**
   * Evaluates the modified Bessel function of the second kind and order n.
   * @param n order.
   * @param x function argument.
   * @return the function value.
   */
  public static double kn(int n, double x) {
    return KN.kn(n,x);
  }

  /**
   * Evaluates the modified Bessel function of the second kind and order n.
   * @param n order.
   * @param x function argument.
   * @return the function value.
   */
  public static float kn(int n, float x) {
    return (float)KN.kn(n,x);
  }

  /**
   * Evaluates the modified Bessel function of the second kind and order n+1/2.
   * @param n order minus 1/2.
   * @param x function argument.
   * @return the function value.
   */
  public static double kn2(int n, double x) {
    return KN2.kn2(n,x);
  }

  /**
   * Evaluates the modified Bessel function of the second kind and order n+1/2.
   * @param n order minus 1/2.
   * @param x function argument.
   * @return the function value.
   */
  public static float kn2(int n, float x) {
    return (float)KN2.kn2(n,x);
  }

  /**
   * Evaluates the gamma function. 
   * @param x function argument; if an integer, must be positive.
   * @return the function value.
   */
  public static double gamma(double x) {
    return GAMMA.gamma(x);
  }

  /**
   * Evaluates the gamma function. 
   * @param x function argument; if an integer, must be positive.
   * @return the function value.
   */
  public static float gamma(float x) {
    return (float)GAMMA.gamma(x);
  }

  ///////////////////////////////////////////////////////////////////////////
  // private

  /**
   * Adapted by Dave Hale from boost::math::bessel_j0
   * Copyright (c) 2006 Xiaogang Zhang
   * Bessel function of the first kind of order zero
   * x &le; 8, minimax rational approximations on intervals,
   * x &gt; 8, Hankel asymptotic expansion in Hart, Computer 
   * Approximations, 1968
   */
  private static class J0 {
    static final double P1[] = {
      -4.1298668500990866786e+11,
       2.7282507878605942706e+10,
      -6.2140700423540120665e+08,
       6.6302997904833794242e+06,
      -3.6629814655107086448e+04,
       1.0344222815443188943e+02,
      -1.2117036164593528341e-01
    };
    static final double Q1[] = {
       2.3883787996332290397e+12,
       2.6328198300859648632e+10,
       1.3985097372263433271e+08,
       4.5612696224219938200e+05,
       9.3614022392337710626e+02,
       1.0,
       0.0
    };
    static final double P2[] = {
      -1.8319397969392084011e+03,
      -1.2254078161378989535e+04,
      -7.2879702464464618998e+03,
       1.0341910641583726701e+04,
       1.1725046279757103576e+04,
       4.4176707025325087628e+03,
       7.4321196680624245801e+02,
       4.8591703355916499363e+01
    };
    static final double Q2[] = {
      -3.5783478026152301072e+05,
       2.4599102262586308984e+05,
      -8.4055062591169562211e+04,
       1.8680990008359188352e+04,
      -2.9458766545509337327e+03,
       3.3307310774649071172e+02,
      -2.5258076240801555057e+01,
       1.0
    };
    static final double PC[] = {
       2.2779090197304684302e+04,
       4.1345386639580765797e+04,
       2.1170523380864944322e+04,
       3.4806486443249270347e+03,
       1.5376201909008354296e+02,
       8.8961548424210455236e-01
    };
    static final double QC[] = {
       2.2779090197304684318e+04,
       4.1370412495510416640e+04,
       2.1215350561880115730e+04,
       3.5028735138235608207e+03,
       1.5711159858080893649e+02,
       1.0
    };
    static final double PS[] = {
      -8.9226600200800094098e+01,
      -1.8591953644342993800e+02,
      -1.1183429920482737611e+02,
      -2.2300261666214198472e+01,
      -1.2441026745835638459e+00,
      -8.8033303048680751817e-03
    };
    static final double QS[] = {
       5.7105024128512061905e+03,
       1.1951131543434613647e+04,
       7.2642780169211018836e+03,
       1.4887231232283756582e+03,
       9.0593769594993125859e+01,
       1.0
    };
    static final double x1  =  2.4048255576957727686e+00;
    static final double x2  =  5.5200781102863106496e+00;
    static final double x11 =  6.160e+02;
    static final double x12 = -1.42444230422723137837e-03;
    static final double x21 =  1.4130e+03;
    static final double x22 =  5.46860286310649596604e-04;
    static double j0(double x) {
      if (x<0.0)
          x = -x;
      if (x==0.0)
        return 1.0;
      double value;
      if (x<=4.0) {
        double y = x*x;
        double r = rational(P1,Q1,y);
        double factor = (x+x1)*((x-x11/256.0)-x12);
        value = factor*r;
      } else if (x <= 8.0) {
        double y = 1.0-(x*x)/64.0;
        double r = rational(P2,Q2,y);
        double factor = (x+x2)*((x-x21/256.0)-x22);
        value = factor*r;
      } else {
        double y = 8.0/x;
        double y2 = y*y;
        double z = x-0.25*PI;
        double rc = rational(PC,QC,y2);
        double rs = rational(PS,QS,y2);
        double factor = sqrt(2.0/(x*PI));
        value = factor*(rc*cos(z)-y*rs*sin(z));
      }
      return value;
    }
  }

  /**
   * Adapted by Dave Hale from boost::math::bessel_j1
   * Copyright (c) 2006 Xiaogang Zhang
   * Bessel function of the first kind of order one
   * x &le; 8, minimax rational approximations on intervals,
   * x &gt; 8, Hankel asymptotic expansion in Hart, Computer 
   * Approximations, 1968
   */
  private static class J1 {
    static final double P1[] = {
      -1.4258509801366645672e+11,
       6.6781041261492395835e+09,
      -1.1548696764841276794e+08,
       9.8062904098958257677e+05,
      -4.4615792982775076130e+03,
       1.0650724020080236441e+01,
      -1.0767857011487300348e-02
    };
    static final double Q1[] = {
       4.1868604460820175290e+12,
       4.2091902282580133541e+10,
       2.0228375140097033958e+08,
       5.9117614494174794095e+05,
       1.0742272239517380498e+03,
       1.0,
       0.0
    };
    static final double P2[] = {
      -1.7527881995806511112e+16,
       1.6608531731299018674e+15,
      -3.6658018905416665164e+13,
       3.5580665670910619166e+11,
      -1.8113931269860667829e+09,
       5.0793266148011179143e+06,
      -7.5023342220781607561e+03,
       4.6179191852758252278e+00
    };
    static final double Q2[] = {
       1.7253905888447681194e+18,
       1.7128800897135812012e+16,
       8.4899346165481429307e+13,
       2.7622777286244082666e+11,
       6.4872502899596389593e+08,
       1.1267125065029138050e+06,
       1.3886978985861357615e+03,
       1.0
    };
    static final double PC[] = {
      -4.4357578167941278571e+06,
      -9.9422465050776411957e+06,
      -6.6033732483649391093e+06,
      -1.5235293511811373833e+06,
      -1.0982405543459346727e+05,
      -1.6116166443246101165e+03,
       0.0
    };
    static final double QC[] = {
      -4.4357578167941278568e+06,
      -9.9341243899345856590e+06,
      -6.5853394797230870728e+06,
      -1.5118095066341608816e+06,
      -1.0726385991103820119e+05,
      -1.4550094401904961825e+03,
       1.0
    };
    static final double PS[] = {
       3.3220913409857223519e+04,
       8.5145160675335701966e+04,
       6.6178836581270835179e+04,
       1.8494262873223866797e+04,
       1.7063754290207680021e+03,
       3.5265133846636032186e+01,
       0.0
    };
    static final double QS[] = {
       7.0871281941028743574e+05,
       1.8194580422439972989e+06,
       1.4194606696037208929e+06,
       4.0029443582266975117e+05,
       3.7890229745772202641e+04,
       8.6383677696049909675e+02,
       1.0
    };
    static final double x1  =  3.8317059702075123156e+00;
    static final double x2  =  7.0155866698156187535e+00;
    static final double x11 =  9.810e+02;
    static final double x12 = -3.2527979248768438556e-04;
    static final double x21 =  1.7960e+03;
    static final double x22 = -3.8330184381246462950e-05;
    static double j1(double x) {
      if (x==0.0)
        return 0.0;
      double w = abs(x);
      double value;
      if (w<=4.0) {
        double y = x*x;
        double r = rational(P1,Q1,y);
        double factor = w*(w+x1)*((w-x11/256.0)-x12);
        value = factor*r;
      } else if (w<=8.0) {
        double y = x*x;
        double r = rational(P2,Q2,y);
        double factor = w*(w+x2)*((w-x21/256.0)-x22);
        value = factor*r;
      } else {
        double y = 8.0/w;
        double y2 = y*y;
        double z = w-0.75*PI;
        double rc = rational(PC,QC,y2);
        double rs = rational(PS,QS,y2);
        double factor = sqrt(2.0/(w*PI));
        value = factor * (rc * cos(z) - y * rs * sin(z));
      }
      return (x>0.0)?value:-value;
    }
  }

  /**
   * Adapted by Dave Hale from boost::math::bessel_i0
   * Copyright (c) 2006 Xiaogang Zhang
   * Modified Bessel function of the first kind of order zero
   * minimax rational approximations on intervals, see
   * Blair and Edwards, Chalk River Report AECL-4928, 1974
   */
  private static class I0 {
    static final double[] P1 = {
      -2.2335582639474375249e+15,
      -5.5050369673018427753e+14,
      -3.2940087627407749166e+13,
      -8.4925101247114157499e+11,
      -1.1912746104985237192e+10,
      -1.0313066708737980747e+08,
      -5.9545626019847898221e+05,
      -2.4125195876041896775e+03,
      -7.0935347449210549190e+00,
      -1.5453977791786851041e-02,
      -2.5172644670688975051e-05,
      -3.0517226450451067446e-08,
      -2.6843448573468483278e-11,
      -1.5982226675653184646e-14,
      -5.2487866627945699800e-18,
    };
    static final double[] Q1 = {
      -2.2335582639474375245e+15,
       7.8858692566751002988e+12,
      -1.2207067397808979846e+10,
       1.0377081058062166144e+07,
      -4.8527560179962773045e+03,
       1.0,
    };
    static final double P2[] = {
      -2.2210262233306573296e-04,
       1.3067392038106924055e-02,
      -4.4700805721174453923e-01,
       5.5674518371240761397e+00,
      -2.3517945679239481621e+01,
       3.1611322818701131207e+01,
      -9.6090021968656180000e+00,
    };
    static final double Q2[] = {
      -5.5194330231005480228e-04,
       3.2547697594819615062e-02,
      -1.1151759188741312645e+00,
       1.3982595353892851542e+01,
      -6.0228002066743340583e+01,
       8.5539563258012929600e+01,
      -3.1446690275135491500e+01,
       1.0,
    };
    static double i0(double x) {
      if (x<0.0)
        x = -x;
      if (x==0.0f)
        return 1.0;
      if (x<=15.0) {
        double y = x*x;
        return poly(P1,y)/poly(Q1,y);
      } else {
        double y = 1.0/x-1.0/15.0;
        double r = poly(P2,y)/poly(Q2,y);
        double factor = exp(x)/sqrt(x);
        return factor*r;
      }
    }
  }

  /**
   * Adapted by Dave Hale from boost::math::bessel_k0
   * Copyright (c) 2006 Xiaogang Zhang
   * Modified Bessel function of the second kind of order zero
   * minimax rational approximations on intervals, see
   * Russon and Blair, Chalk River Report AECL-3461, 1969
   */
  private static class K0 {
    static final double[] P1 = {
       2.4708152720399552679e+03,
       5.9169059852270512312e+03,
       4.6850901201934832188e+02,
       1.1999463724910714109e+01,
       1.3166052564989571850e-01,
       5.8599221412826100000e-04
    };
    static final double[] Q1 = {
       2.1312714303849120380e+04,
      -2.4994418972832303646e+02,
       1.0
    };
    static final double[] P2 = {
      -1.6128136304458193998e+06,
      -3.7333769444840079748e+05,
      -1.7984434409411765813e+04,
      -2.9501657892958843865e+02,
      -1.6414452837299064100e+00
    };
    static final double[] Q2 = {
      -1.6128136304458193998e+06,
       2.9865713163054025489e+04,
      -2.5064972445877992730e+02,
       1.0
    };
    static final double[] P3 = {
       1.1600249425076035558e+02,
       2.3444738764199315021e+03,
       1.8321525870183537725e+04,
       7.1557062783764037541e+04,
       1.5097646353289914539e+05,
       1.7398867902565686251e+05,
       1.0577068948034021957e+05,
       3.1075408980684392399e+04,
       3.6832589957340267940e+03,
       1.1394980557384778174e+02
    };
    static final double[] Q3 = {
       9.2556599177304839811e+01,
       1.8821890840982713696e+03,
       1.4847228371802360957e+04,
       5.8824616785857027752e+04,
       1.2689839587977598727e+05,
       1.5144644673520157801e+05,
       9.7418829762268075784e+04,
       3.1474655750295278825e+04,
       4.4329628889746408858e+03,
       2.0013443064949242491e+02,
       1.0
    };
    static double k0(double x) {
      if (x<0.0)
        return Double.NaN;
      if (x==0.0f)
        return Double.POSITIVE_INFINITY;
      if (x<=1.0) {
        double y = x*x;
        double r1 = poly(P1,y)/poly(Q1,y);
        double r2 = poly(P2,y)/poly(Q2,y);
        double factor = log(x);
        return r1-factor*r2;
      } else {
        double y = 1.0/x;
        double r = poly(P3,y)/poly(Q3,y);
        double factor = exp(-x)/sqrt(x);
        return factor*r;
      }
    }
  }

  /**
   * Adapted from boost::math::bessel_k1
   * Copyright (c) 2006 Xiaogang Zhang
   * Modified Bessel function of the second kind of order one
   * minimax rational approximations on intervals, see
   * Russon and Blair, Chalk River Report AECL-3461, 1969
   */
  private static class K1 {
    static final double[] P1 = {
      -2.2149374878243304548e+06,
       7.1938920065420586101e+05,
       1.7733324035147015630e+05,
       7.1885382604084798576e+03,
       9.9991373567429309922e+01,
       4.8127070456878442310e-01
    };
    static final double[] Q1 = {
      -2.2149374878243304548e+06,
       3.7264298672067697862e+04,
      -2.8143915754538725829e+02,
       1.0
    };
    static final double[] P2 = {
       0.0,
      -1.3531161492785421328e+06,
      -1.4758069205414222471e+05,
      -4.5051623763436087023e+03,
      -5.3103913335180275253e+01,
      -2.2795590826955002390e-01
    };
    static final double[] Q2 = {
      -2.7062322985570842656e+06,
       4.3117653211351080007e+04,
      -3.0507151578787595807e+02,
       1.0
    };
    static final double[] P3 = {
       2.2196792496874548962e+00,
       4.4137176114230414036e+01,
       3.4122953486801312910e+02,
       1.3319486433183221990e+03,
       2.8590657697910288226e+03,
       3.4540675585544584407e+03,
       2.3123742209168871550e+03,
       8.1094256146537402173e+02,
       1.3182609918569941308e+02,
       7.5584584631176030810e+00,
       6.4257745859173138767e-02
    };
    static final double[] Q3 = {
       1.7710478032601086579e+00,
       3.4552228452758912848e+01,
       2.5951223655579051357e+02,
       9.6929165726802648634e+02,
       1.9448440788918006154e+03,
       2.1181000487171943810e+03,
       1.2082692316002348638e+03,
       3.3031020088765390854e+02,
       3.6001069306861518855e+01,
       1.0
    };
    static double k1(double x) {
      if (x<0.0)
        return Double.NaN;
      if (x==0.0f)
        return Double.POSITIVE_INFINITY;
      if (x<=1.0) {
        double y = x*x;
        double r1 = poly(P1,y)/poly(Q1,y);
        double r2 = poly(P2,y)/poly(Q2,y);
        double factor = log(x);
        return (r1+factor*r2)/x;
      } else {
        double y = 1.0/x;
        double r = poly(P3,y)/poly(Q3,y);
        double factor = exp(-x)/sqrt(x);
        return factor*r;
      }
    }
  }

  /**
   * Adapted from boost::math::bessel_kn
   * Copyright (c) 2006 Xiaogang Zhang
   * Modified Bessel function of the second kind of integer order
   * K_n(z) is the dominant solution, forward recurrence always OK 
   * (though unstable)
   */
  private static class KN {
    static double kn(int n, double x) {
      if (x<0.0)
        return Double.NaN;
      if (x==0.0)
        return Double.POSITIVE_INFINITY;
      if (n<0)
        n = -n;
      if (n==0)
        return K0.k0(x);
      if (n==1)
        return K1.k1(x);
      double prev = k0(x);
      double curr = k1(x);
      int k = 1;
      double scale = 1.0;
      double value;
      do {
        double fact = 2.0*k/x;
        if ((Double.MAX_VALUE-abs(prev))/fact<abs(curr)) {
          scale /= curr;
          prev /= curr;
          curr = 1.0;
        }
        value = fact*curr+prev;
        prev = curr;
        curr = value;
        ++k;
      } while (k<n);
      if (Double.MAX_VALUE*scale<abs(value))
        return sign(scale)*sign(value)*Double.POSITIVE_INFINITY;
      value /= scale;
      return value;
    }
  }

  /**
   * Modified Bessel function of the second kind and order n+1/2.
   * odd-half-integer order v = 1/2, 3/2, 5/2, ....
   * Dave Hale, Colorado School of Mines
   */ 
  private static class KN2 {
    static double kn2(int n, double x) {
      if (x<0.0)
        return Double.NaN;
      if (x==0.0)
        return Double.POSITIVE_INFINITY;
      double value = sqrt(0.5*PI/x)*exp(-x);
      if (n==0)
        return value;
      if (n<0)
        n = -n-1;
      double facn = 1.0;
      double facd = 1.0;
      double facx = 0.5/x;
      double powx = 1.0;
      double sum = 1.0;
      for (int j=1; j<=n; ++j) {
        facn *= (n+j)*(n+1-j);
        facd *= j;
        powx *= facx;
        sum += facn/facd*powx;
      }
      value *= sum;
      return value;
    }
  }

  /**
   * Adapted from boost::math::gamma.
   * Copyright (c) 2006,2007 John Maddock
   * Copyright (c) 2007 Paul A. Bristow
   */
  private static class GAMMA {
    static double gamma(double x) {
      double result = 1.0;
      if (x<=0.0) {
        Check.argument(floor(x)!=x,"if x is an integer, must be positive");
        if (x<=-20.0) {
          result = gamma(-x)*sinpx(x);
          result = -PI/result;
          return result;
        }
        while (x<0.0) { // shift x to > 1
          result /= x;
          x += 1.0;
        }
      }
      if (floor(x)==x) {
        result *= factorial((int)x-1);
      } else {
        result *= LANCZOS.sum(x);
        double xgh = x+LANCZOS.G-0.5;
        result *= pow(xgh,x-0.5)/exp(xgh);
      }
      return result;
    }
    // x*sin(pi*x), with special care where x is near a whole number
    private static double sinpx(double x) {
      double sign = 1.0;
      if (x<0.0) {
        x = -x;
      } else {
        sign = -sign;
      }
      double fx = floor(x);
      double dist;
      if (((int)fx)%2!=0) {
        fx += 1.0;
        dist = fx-x;
        sign = -sign;
      } else {
        dist = x-fx;
      }
      if (dist>0.5)
        dist = 1.0-dist;
      double result = sin(dist*PI);
      return sign*x*result;
    }
  }

  /**
   * Adapted from boost::math::lanczos.
   * Copyright (c) 2006 John Maddock
   * Lanczos sum for N=11, G=10.900511. Produces slightly better than 
   * double precision when evaluated at extended-double precision.
   */
  private static class LANCZOS {
    static final double G = 10.90051099999999983936049829935654997826;
    static double sum(double x) {
      return rational(num,den,x);
    }
    private static final double[] num = {
      38474670393.31776828316099004518914832218,
      36857665043.51950660081971227404959150474,
      15889202453.72942008945006665994637853242,
      4059208354.298834770194507810788393801607,
      680547661.1834733286087695557084801366446,
      78239755.00312005289816041245285376206263,
      6246580.776401795264013335510453568106366,
      341986.3488721347032223777872763188768288,
      12287.19451182455120096222044424100527629,
      261.6140441641668190791708576058805625502,
      2.506628274631000502415573855452633787834
    };
    private static final double[] den = {
      0.0,
      362880.0,
      1026576.0,
      1172700.0,
      723680.0,
      269325.0,
      63273.0,
      9450.0,
      870.0,
      45.0,
      1.0
    };
  }

  /**
   * Adapted from boost::math.
   * Uses a table of factorial function values for all integer 
   * arguments for which the result can be represented by a double. 
   * For larger arguments, returns positive infinity.
   */
  private static double factorial(int i) {
    Check.argument(i>=0,"i is non-negative");
    return (i<=MAX_FACTORIAL_ARG) ?
      FACTORIALS[i] :
      Double.POSITIVE_INFINITY;
  }
  private static final int MAX_FACTORIAL_ARG = 170;
  private static final double[] FACTORIALS = {
    1.0,
    1.0,
    2.0,
    6.0,
    24.0,
    120.0,
    720.0,
    5040.0,
    40320.0,
    362880.0,
    3628800.0,
    39916800.0,
    479001600.0,
    6227020800.0,
    87178291200.0,
    1307674368000.0,
    20922789888000.0,
    355687428096000.0,
    6402373705728000.0,
    121645100408832000.0,
    0.243290200817664e19,
    0.5109094217170944e20,
    0.112400072777760768e22,
    0.2585201673888497664e23,
    0.62044840173323943936e24,
    0.15511210043330985984e26,
    0.403291461126605635584e27,
    0.10888869450418352160768e29,
    0.304888344611713860501504e30,
    0.8841761993739701954543616e31,
    0.26525285981219105863630848e33,
    0.822283865417792281772556288e34,
    0.26313083693369353016721801216e36,
    0.868331761881188649551819440128e37,
    0.29523279903960414084761860964352e39,
    0.103331479663861449296666513375232e41,
    0.3719933267899012174679994481508352e42,
    0.137637530912263450463159795815809024e44,
    0.5230226174666011117600072241000742912e45,
    0.203978820811974433586402817399028973568e47,
    0.815915283247897734345611269596115894272e48,
    0.3345252661316380710817006205344075166515e50,
    0.1405006117752879898543142606244511569936e52,
    0.6041526306337383563735513206851399750726e53,
    0.265827157478844876804362581101461589032e55,
    0.1196222208654801945619631614956577150644e57,
    0.5502622159812088949850305428800254892962e58,
    0.2586232415111681806429643551536119799692e60,
    0.1241391559253607267086228904737337503852e62,
    0.6082818640342675608722521633212953768876e63,
    0.3041409320171337804361260816606476884438e65,
    0.1551118753287382280224243016469303211063e67,
    0.8065817517094387857166063685640376697529e68,
    0.427488328406002556429801375338939964969e70,
    0.2308436973392413804720927426830275810833e72,
    0.1269640335365827592596510084756651695958e74,
    0.7109985878048634518540456474637249497365e75,
    0.4052691950487721675568060190543232213498e77,
    0.2350561331282878571829474910515074683829e79,
    0.1386831185456898357379390197203894063459e81,
    0.8320987112741390144276341183223364380754e82,
    0.507580213877224798800856812176625227226e84,
    0.3146997326038793752565312235495076408801e86,
    0.1982608315404440064116146708361898137545e88,
    0.1268869321858841641034333893351614808029e90,
    0.8247650592082470666723170306785496252186e91,
    0.5443449390774430640037292402478427526443e93,
    0.3647111091818868528824985909660546442717e95,
    0.2480035542436830599600990418569171581047e97,
    0.1711224524281413113724683388812728390923e99,
    0.1197857166996989179607278372168909873646e101,
    0.8504785885678623175211676442399260102886e102,
    0.6123445837688608686152407038527467274078e104,
    0.4470115461512684340891257138125051110077e106,
    0.3307885441519386412259530282212537821457e108,
    0.2480914081139539809194647711659403366093e110,
    0.188549470166605025498793226086114655823e112,
    0.1451830920282858696340707840863082849837e114,
    0.1132428117820629783145752115873204622873e116,
    0.8946182130782975286851441715398316520698e117,
    0.7156945704626380229481153372318653216558e119,
    0.5797126020747367985879734231578109105412e121,
    0.4753643337012841748421382069894049466438e123,
    0.3945523969720658651189747118012061057144e125,
    0.3314240134565353266999387579130131288001e127,
    0.2817104114380550276949479442260611594801e129,
    0.2422709538367273238176552320344125971528e131,
    0.210775729837952771721360051869938959523e133,
    0.1854826422573984391147968456455462843802e135,
    0.1650795516090846108121691926245361930984e137,
    0.1485715964481761497309522733620825737886e139,
    0.1352001527678402962551665687594951421476e141,
    0.1243841405464130725547532432587355307758e143,
    0.1156772507081641574759205162306240436215e145,
    0.1087366156656743080273652852567866010042e147,
    0.103299784882390592625997020993947270954e149,
    0.9916779348709496892095714015418938011582e150,
    0.9619275968248211985332842594956369871234e152,
    0.942689044888324774562618574305724247381e154,
    0.9332621544394415268169923885626670049072e156,
    0.9332621544394415268169923885626670049072e158,
    0.9425947759838359420851623124482936749562e160,
    0.9614466715035126609268655586972595484554e162,
    0.990290071648618040754671525458177334909e164,
    0.1029901674514562762384858386476504428305e167,
    0.1081396758240290900504101305800329649721e169,
    0.1146280563734708354534347384148349428704e171,
    0.1226520203196137939351751701038733888713e173,
    0.132464181945182897449989183712183259981e175,
    0.1443859583202493582204882102462797533793e177,
    0.1588245541522742940425370312709077287172e179,
    0.1762952551090244663872161047107075788761e181,
    0.1974506857221074023536820372759924883413e183,
    0.2231192748659813646596607021218715118256e185,
    0.2543559733472187557120132004189335234812e187,
    0.2925093693493015690688151804817735520034e189,
    0.339310868445189820119825609358857320324e191,
    0.396993716080872089540195962949863064779e193,
    0.4684525849754290656574312362808384164393e195,
    0.5574585761207605881323431711741977155627e197,
    0.6689502913449127057588118054090372586753e199,
    0.8094298525273443739681622845449350829971e201,
    0.9875044200833601362411579871448208012564e203,
    0.1214630436702532967576624324188129585545e206,
    0.1506141741511140879795014161993280686076e208,
    0.1882677176888926099743767702491600857595e210,
    0.237217324288004688567714730513941708057e212,
    0.3012660018457659544809977077527059692324e214,
    0.3856204823625804217356770659234636406175e216,
    0.4974504222477287440390234150412680963966e218,
    0.6466855489220473672507304395536485253155e220,
    0.8471580690878820510984568758152795681634e222,
    0.1118248651196004307449963076076169029976e225,
    0.1487270706090685728908450891181304809868e227,
    0.1992942746161518876737324194182948445223e229,
    0.269047270731805048359538766214698040105e231,
    0.3659042881952548657689727220519893345429e233,
    0.5012888748274991661034926292112253883237e235,
    0.6917786472619488492228198283114910358867e237,
    0.9615723196941089004197195613529725398826e239,
    0.1346201247571752460587607385894161555836e242,
    0.1898143759076170969428526414110767793728e244,
    0.2695364137888162776588507508037290267094e246,
    0.3854370717180072770521565736493325081944e248,
    0.5550293832739304789551054660550388118e250,
    0.80479260574719919448490292577980627711e252,
    0.1174997204390910823947958271638517164581e255,
    0.1727245890454638911203498659308620231933e257,
    0.2556323917872865588581178015776757943262e259,
    0.380892263763056972698595524350736933546e261,
    0.571338395644585459047893286526105400319e263,
    0.8627209774233240431623188626544191544816e265,
    0.1311335885683452545606724671234717114812e268,
    0.2006343905095682394778288746989117185662e270,
    0.308976961384735088795856467036324046592e272,
    0.4789142901463393876335775239063022722176e274,
    0.7471062926282894447083809372938315446595e276,
    0.1172956879426414428192158071551315525115e279,
    0.1853271869493734796543609753051078529682e281,
    0.2946702272495038326504339507351214862195e283,
    0.4714723635992061322406943211761943779512e285,
    0.7590705053947218729075178570936729485014e287,
    0.1229694218739449434110178928491750176572e290,
    0.2004401576545302577599591653441552787813e292,
    0.3287218585534296227263330311644146572013e294,
    0.5423910666131588774984495014212841843822e296,
    0.9003691705778437366474261723593317460744e298,
    0.1503616514864999040201201707840084015944e301,
    0.2526075744973198387538018869171341146786e303,
    0.4269068009004705274939251888899566538069e305,
    0.7257415615307998967396728211129263114717e307,
  };

  private static double poly(double[] c, double x) {
    int i = c.length-1;
    double sum = c[i];
    for (--i; i>=0; --i) {
      sum *= x;
      sum += c[i];
    }
    return sum;
  }

  private static double sign(double x) {
    if (x>0.0) return 1.0;
    else if (x<0.0) return -1.0;
    else return 0.0;
  }

  private static double rational(double[] num, double[] den, double z) {
    int n = num.length;
    double s1,s2;
    if (z<=1.0) {
      s1 = num[n-1];
      s2 = den[n-1];
      for (int i=n-2; i>=0; --i) {
        s1 *= z;
        s2 *= z;
        s1 += num[i];
        s2 += den[i];
      }
    } else {
      z = 1.0/z;
      s1 = num[0];
      s2 = den[0];
      for (int i=1; i<n; ++i) {
        s1 *= z;
        s2 *= z;
        s1 += num[i];
        s2 += den[i];
      }
    }
    return s1/s2;
  }
}
